{"text": "Prompt: Fix a Python error.\nError: IndexError at line 3\nMessage: list index out of range\nCode line: print(items[i])\nVariables: items\nIntent: loop, function\nCompletion: Corrected Code:\n```python\nfor i in range(len(items)):\n    print(items[i])\n```\nExplanation: The IndexError occurs because the index 'i' exceeds the list length. Using len(items) ensures valid indices.\nBest Practice: Check list bounds or use try-except."}
{"text": "Prompt: Fix a Python error.\nError: IndexError at line 5\nMessage: list index out of range\nCode line: value = array[i]\nVariables: array\nIntent: loop\nCompletion: Corrected Code:\n```python\ntry:\n    value = array[i]\nexcept IndexError:\n    value = None\n```\nExplanation: The IndexError is due to an invalid index. A try-except block handles the error gracefully.\nBest Practice: Use try-except for error-prone operations."}
{"text": "Prompt: Fix a Python error.\nError: IndexError at line 4\nMessage: list index out of range\nCode line: result = data[i]\nVariables: data\nIntent: function\nCompletion: Corrected Code:\n```python\nif i < len(data):\n    result = data[i]\n```\nExplanation: The IndexError occurs due to an out-of-bounds index. Checking the length prevents the error.\nBest Practice: Validate indices before accessing lists."}
{"text": "Prompt: Fix a Java error.\nError: NullPointerException at line 4\nMessage: Cannot invoke method on null object\nCode line: System.out.println(s.length());\nVariables: s\nIntent: function, class\nCompletion: Corrected Code:\n```java\nif (s != null) {\n    System.out.println(s.length());\n}\n```\nExplanation: The NullPointerException occurs because 's' is null. Checking for null prevents the error.\nBest Practice: Use null checks or Optional."}
{"text": "Prompt: Fix a Java error.\nError: NullPointerException at line 6\nMessage: null object\nCode line: obj.method();\nVariables: obj\nIntent: function\nCompletion: Corrected Code:\n```java\nobj = new Object(); // Initialize\nobj.method();\n```\nExplanation: The NullPointerException occurs due to an uninitialized object. Initializing 'obj' fixes it.\nBest Practice: Initialize objects at declaration."}
{"text": "Prompt: Fix a Java error.\nError: NullPointerException at line 5\nMessage: null reference\nCode line: str.toUpperCase();\nVariables: str\nIntent: method\nCompletion: Corrected Code:\n```java\nstr = str != null ? str.toUpperCase() : \"\";\n```\nExplanation: The NullPointerException occurs because 'str' is null. Using a ternary operator ensures safety.\nBest Practice: Use null-safe operations."}
{"text": "Prompt: Fix a C++ error.\nError: out_of_range at line 4\nMessage: vector index exceeds size\nCode line: int x = vec[10];\nVariables: vec\nIntent: function\nCompletion: Corrected Code:\n```cpp\nif (10 < vec.size()) {\n    int x = vec[10];\n}\n```\nExplanation: The out_of_range error occurs because the index exceeds the vector size. Checking the size prevents the error.\nBest Practice: Use at() for bounds checking."}
{"text": "Prompt: Fix a C++ error.\nError: out_of_range at line 5\nMessage: invalid vector index\nCode line: value = vector[5];\nVariables: vector\nIntent: function\nCompletion: Corrected Code:\n```cpp\nvalue = vector.at(5);\n```\nExplanation: The out_of_range error is due to an invalid index. Using at() provides bounds checking.\nBest Practice: Prefer at() over [] for safety."}
{"text": "Prompt: Fix a C++ error.\nError: out_of_range at line 6\nMessage: vector access out of bounds\nCode line: result = arr[8];\nVariables: arr\nIntent: loop\nCompletion: Corrected Code:\n```cpp\nresult = arr.at(8);\n```\nExplanation: The out_of_range error occurs due to an invalid index. The at() method checks bounds automatically.\nBest Practice: Use at() for safe vector access."}
{"text": "Prompt: Fix a Python error.\nError: AttributeError at line 4\nMessage: 'NoneType' object has no attribute 'append'\nCode line: result.append(item)\nVariables: result\nIntent: list operation\nCompletion: Corrected Code:\n`python\nresult = result or []\nresult.append(item)\n`\nExplanation: The error occurs when result is None. Initialize the list if None.\nBest Practice: Initialize mutable defaults properly."}
{"text": "Prompt: Fix a Python error.\nError: IndentationError at line 3\nMessage: expected an indented block\nCode line: print('Hello')\nVariables: None\nIntent: function\nCompletion: Corrected Code:\n`python\nif True:\n    print('Hello')\n`\nExplanation: Python requires proper indentation after control structures. Add proper indentation.\nBest Practice: Use consistent indentation (4 spaces recommended)."}
{"text": "Prompt: Fix a Python error.\nError: ZeroDivisionError at line 2\nMessage: division by zero\nCode line: result = a / b\nVariables: a, b\nIntent: arithmetic\nCompletion: Corrected Code:\n`python\nif b != 0:\n    result = a / b\nelse:\n    result = float('inf')\n`\nExplanation: Division by zero causes ZeroDivisionError. Check denominator before division.\nBest Practice: Always validate inputs for mathematical operations."}
{"text": "Prompt: Fix a Python error.\nError: ImportError at line 1\nMessage: No module named 'nonexistent'\nCode line: import nonexistent\nVariables: None\nIntent: import\nCompletion: Corrected Code:\n`python\ntry:\n    import nonexistent\nexcept ImportError:\n    print('Module not found, using alternative')\n`\nExplanation: ImportError occurs when module doesn't exist. Use try-except for optional imports.\nBest Practice: Handle missing dependencies gracefully."}
{"text": "Prompt: Fix a Java error.\nError: StringIndexOutOfBoundsException at line 3\nMessage: String index out of range: 10\nCode line: char c = str.charAt(10);\nVariables: str\nIntent: string operation\nCompletion: Corrected Code:\n`java\nif (str.length() > 10) {\n    char c = str.charAt(10);\n}\n`\nExplanation: StringIndexOutOfBoundsException occurs when index exceeds string length. Check length first.\nBest Practice: Always validate string indices."}
{"text": "Prompt: Fix a Java error.\nError: NumberFormatException at line 4\nMessage: For input string: 'abc'\nCode line: int num = Integer.parseInt(input);\nVariables: input\nIntent: type conversion\nCompletion: Corrected Code:\n`java\ntry {\n    int num = Integer.parseInt(input);\n} catch (NumberFormatException e) {\n    int num = 0; // default value\n}\n`\nExplanation: NumberFormatException occurs with invalid number format. Use try-catch for parsing.\nBest Practice: Always handle parsing exceptions."}
{"text": "Prompt: Fix a C++ error.\nError: bad_alloc at line 3\nMessage: std::bad_alloc\nCode line: int* arr = new int[size];\nVariables: arr, size\nIntent: memory allocation\nCompletion: Corrected Code:\n`cpp\ntry {\n    int* arr = new int[size];\n} catch (std::bad_alloc& e) {\n    arr = nullptr;\n}\n`\nExplanation: bad_alloc occurs when memory allocation fails. Use try-catch for allocation.\nBest Practice: Always check allocation success and use smart pointers."}
{"text": "Prompt: Fix a C++ error.\nError: double free at line 5\nMessage: double free or corruption\nCode line: delete ptr;\nVariables: ptr\nIntent: memory management\nCompletion: Corrected Code:\n`cpp\nif (ptr != nullptr) {\n    delete ptr;\n    ptr = nullptr;\n}\n`\nExplanation: Double free occurs when deleting same pointer twice. Set to nullptr after delete.\nBest Practice: Use smart pointers to avoid manual memory management."}
{"text": "Prompt: Fix a JavaScript error.\nError: SyntaxError at line 2\nMessage: Unexpected token '}'\nCode line: if (x > 0 {\n    console.log(x);\n}\nVariables: x\nIntent: conditional\nCompletion: Corrected Code:\n`javascript\nif (x > 0) {\n    console.log(x);\n}\n`\nExplanation: SyntaxError due to missing closing parenthesis. Add missing parenthesis.\nBest Practice: Use proper IDE with syntax highlighting."}
{"text": "Prompt: Fix a JavaScript error.\nError: RangeError at line 3\nMessage: Maximum call stack size exceeded\nCode line: function factorial(n) { return n * factorial(n); }\nVariables: n\nIntent: recursion\nCompletion: Corrected Code:\n`javascript\nfunction factorial(n) {\n    if (n <= 1) return 1;\n    return n * factorial(n - 1);\n}\n`\nExplanation: RangeError due to infinite recursion. Add base case for recursion.\nBest Practice: Always include base cases in recursive functions."}
{"text": "Prompt: Fix a Python error.\nError: KeyError at line 3\nMessage: 'username'\nCode line: print(user['username'])\nVariables: user\nIntent: dictionary access\nCompletion: Corrected Code:\n`python\nprint(user.get('username', 'default'))\n`\nExplanation: KeyError occurs when dictionary key doesn't exist. Use dict.get() for safe access.\nBest Practice: Always handle missing dictionary keys gracefully."}
{"text": "Prompt: Fix a Python error.\nError: ValueError at line 2\nMessage: invalid literal for int() with base 10: 'abc'\nCode line: num = int(input_str)\nVariables: input_str\nIntent: type conversion\nCompletion: Corrected Code:\n`python\ntry:\n    num = int(input_str)\nexcept ValueError:\n    num = 0\n`\nExplanation: ValueError occurs when converting invalid strings to int. Use try-except for safe conversion.\nBest Practice: Validate input before type conversion."}
{"text": "Prompt: Fix a Python error.\nError: TypeError at line 3\nMessage: can only concatenate str (not \"int\") to str\nCode line: result = \"Age: \" + age\nVariables: age\nIntent: string formatting\nCompletion: Corrected Code:\n`python\nresult = f\"Age: {age}\"\n`\nExplanation: TypeError occurs when mixing incompatible types. Use f-strings for string formatting.\nBest Practice: Use f-strings or str() for type conversion."}
{"text": "Prompt: Fix a Java error.\nError: ArrayIndexOutOfBoundsException at line 5\nMessage: Index 3 out of bounds for length 3\nCode line: String item = array[3];\nVariables: array\nIntent: array access\nCompletion: Corrected Code:\n`java\nif (array.length > 3) {\n    String item = array[3];\n}\n`\nExplanation: Exception occurs when accessing beyond array bounds. Check array length before access.\nBest Practice: Always validate array indices before access."}
{"text": "Prompt: Fix a Java error.\nError: ClassCastException at line 6\nMessage: java.lang.String cannot be cast to java.lang.Integer\nCode line: Integer num = (Integer) obj;\nVariables: obj\nIntent: type casting\nCompletion: Corrected Code:\n`java\nif (obj instanceof Integer) {\n    Integer num = (Integer) obj;\n}\n`\nExplanation: ClassCastException occurs with invalid casting. Check object type before casting.\nBest Practice: Use instanceof before type casting."}
{"text": "Prompt: Fix a C++ error.\nError: segmentation fault at line 7\nMessage: invalid memory access\nCode line: *ptr = 42;\nVariables: ptr\nIntent: pointer manipulation\nCompletion: Corrected Code:\n`cpp\nif (ptr != nullptr) {\n    *ptr = 42;\n}\n`\nExplanation: Segfault occurs when dereferencing null pointer. Always check pointers before use.\nBest Practice: Initialize pointers and check for null before dereferencing."}
{"text": "Prompt: Fix a JavaScript error.\nError: TypeError at line 3\nMessage: Cannot read property 'length' of undefined\nCode line: const len = arr.length;\nVariables: arr\nIntent: array operation\nCompletion: Corrected Code:\n`javascript\nconst len = arr?.length || 0;\n`\nExplanation: TypeError occurs when accessing properties of undefined. Use optional chaining.\nBest Practice: Handle undefined/null values defensively."}
{"text": "Prompt: Fix a JavaScript error.\nError: ReferenceError at line 2\nMessage: variable is not defined\nCode line: console.log(myVar);\nVariables: myVar\nIntent: variable access\nCompletion: Corrected Code:\n`javascript\nconst myVar = \"default\";\nconsole.log(myVar);\n`\nExplanation: ReferenceError occurs when using undeclared variables. Always declare variables before use.\nBest Practice: Use 'const' or 'let' for variable declarations."}
{"text": "Prompt: Fix a Python error.\nError: FileNotFoundError at line 2\nMessage: [Errno 2] No such file or directory: 'data.txt'\nCode line: with open('data.txt', 'r') as f:\nVariables: f\nIntent: file handling\nCompletion: Corrected Code:\n```python\ntry:\n    with open('data.txt', 'r') as f:\n        content = f.read()\nexcept FileNotFoundError:\n    print('File not found, creating default')\n    content = ''\n```\nExplanation: FileNotFoundError occurs when trying to open non-existent files. Use try-except for file operations.\nBest Practice: Always handle file exceptions and provide fallbacks."}
{"text": "Prompt: Fix a Python error.\nError: UnboundLocalError at line 4\nMessage: local variable 'count' referenced before assignment\nCode line: count += 1\nVariables: count\nIntent: variable assignment\nCompletion: Corrected Code:\n```python\ncount = 0  # Initialize before use\ncount += 1\n```\nExplanation: UnboundLocalError occurs when referencing uninitialized local variables. Initialize variables before use.\nBest Practice: Always initialize variables before using them."}
{"text": "Prompt: Fix a Python error.\nError: RecursionError at line 3\nMessage: maximum recursion depth exceeded\nCode line: return factorial(n)\nVariables: n\nIntent: recursion\nCompletion: Corrected Code:\n```python\ndef factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)\n```\nExplanation: RecursionError occurs without base case. Always include termination condition in recursive functions.\nBest Practice: Define clear base cases for all recursive functions."}
{"text": "Prompt: Fix a Python error.\nError: ModuleNotFoundError at line 1\nMessage: No module named 'requests'\nCode line: import requests\nVariables: None\nIntent: import\nCompletion: Corrected Code:\n```python\ntry:\n    import requests\nexcept ModuleNotFoundError:\n    print('requests module not installed')\n    # Use alternative like urllib\n    import urllib.request as requests\n```\nExplanation: ModuleNotFoundError occurs when importing unavailable modules. Handle missing dependencies gracefully.\nBest Practice: Provide fallbacks for optional dependencies."}
{"text": "Prompt: Fix a Java error.\nError: ConcurrentModificationException at line 5\nMessage: Collection was modified during iteration\nCode line: for (String item : list) { list.remove(item); }\nVariables: list, item\nIntent: iteration, collection\nCompletion: Corrected Code:\n```java\nIterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    String item = iterator.next();\n    iterator.remove();\n}\n```\nExplanation: ConcurrentModificationException occurs when modifying collection during iteration. Use Iterator.remove().\nBest Practice: Use Iterator methods for safe collection modification."}
{"text": "Prompt: Fix a Java error.\nError: IllegalArgumentException at line 3\nMessage: argument cannot be negative\nCode line: Thread.sleep(-1000);\nVariables: None\nIntent: threading\nCompletion: Corrected Code:\n```java\nif (sleepTime > 0) {\n    Thread.sleep(sleepTime);\n}\n```\nExplanation: IllegalArgumentException occurs with invalid method arguments. Validate parameters before use.\nBest Practice: Always validate input parameters in methods."}
{"text": "Prompt: Fix a Java error.\nError: OutOfMemoryError at line 4\nMessage: Java heap space\nCode line: int[] bigArray = new int[Integer.MAX_VALUE];\nVariables: bigArray\nIntent: memory allocation\nCompletion: Corrected Code:\n```java\ntry {\n    int[] bigArray = new int[reasonableSize];\n} catch (OutOfMemoryError e) {\n    System.err.println('Not enough memory');\n}\n```\nExplanation: OutOfMemoryError occurs with excessive memory allocation. Use reasonable sizes and handle memory errors.\nBest Practice: Monitor memory usage and implement proper error handling."}
{"text": "Prompt: Fix a C++ error.\nError: stack overflow at line 5\nMessage: stack overflow in recursive function\nCode line: return fibonacci(n-1) + fibonacci(n-2);\nVariables: n\nIntent: recursion\nCompletion: Corrected Code:\n```cpp\nint fibonacci(int n) {\n    if (n <= 1) return n;\n    return fibonacci(n-1) + fibonacci(n-2);\n}\n```\nExplanation: Stack overflow occurs without base case in recursion. Add proper termination conditions.\nBest Practice: Always define base cases and consider iterative alternatives for deep recursion."}
{"text": "Prompt: Fix a C++ error.\nError: memory leak at line 6\nMessage: memory not deallocated\nCode line: int* ptr = new int(42);\nVariables: ptr\nIntent: memory management\nCompletion: Corrected Code:\n```cpp\nstd::unique_ptr<int> ptr = std::make_unique<int>(42);\n// or manually: int* ptr = new int(42); delete ptr;\n```\nExplanation: Memory leak occurs when allocated memory isn't freed. Use smart pointers or manual delete.\nBest Practice: Prefer smart pointers over raw pointers for automatic memory management."}
{"text": "Prompt: Fix a C++ error.\nError: dangling pointer at line 7\nMessage: accessing freed memory\nCode line: *ptr = 10;\nVariables: ptr\nIntent: pointer access\nCompletion: Corrected Code:\n```cpp\nif (ptr != nullptr) {\n    *ptr = 10;\n} else {\n    ptr = new int(10);\n}\n```\nExplanation: Dangling pointer error occurs when accessing freed memory. Check pointer validity before use.\nBest Practice: Set pointers to nullptr after deletion and always validate before dereferencing."}
{"text": "Prompt: Fix a JavaScript error.\nError: TypeError at line 4\nMessage: Cannot read properties of null\nCode line: document.getElementById('button').addEventListener('click', handler);\nVariables: button\nIntent: DOM manipulation\nCompletion: Corrected Code:\n```javascript\nconst button = document.getElementById('button');\nif (button) {\n    button.addEventListener('click', handler);\n}\n```\nExplanation: TypeError occurs when element doesn't exist. Check element existence before manipulation.\nBest Practice: Always validate DOM elements before accessing their properties."}
{"text": "Prompt: Fix a JavaScript error.\nError: RangeError at line 3\nMessage: Invalid array length\nCode line: const arr = new Array(-5);\nVariables: arr\nIntent: array creation\nCompletion: Corrected Code:\n```javascript\nconst length = Math.max(0, inputLength);\nconst arr = new Array(length);\n```\nExplanation: RangeError occurs with invalid array length. Validate array size before creation.\nBest Practice: Ensure array lengths are non-negative integers."}
{"text": "Prompt: Fix a JavaScript error.\nError: SyntaxError at line 2\nMessage: Unexpected end of JSON input\nCode line: const data = JSON.parse(response);\nVariables: data, response\nIntent: JSON parsing\nCompletion: Corrected Code:\n```javascript\ntry {\n    const data = JSON.parse(response || '{}');\n} catch (SyntaxError) {\n    const data = {};\n}\n```\nExplanation: SyntaxError occurs with malformed JSON. Use try-catch for JSON parsing operations.\nBest Practice: Always handle JSON parsing errors with proper fallbacks."}
{"text": "Prompt: Fix a Python error.\nError: StopIteration at line 4\nMessage: generator exhausted\nCode line: value = next(generator)\nVariables: generator, value\nIntent: iteration\nCompletion: Corrected Code:\n```python\ntry:\n    value = next(generator)\nexcept StopIteration:\n    value = None  # or default value\n```\nExplanation: StopIteration occurs when generator is exhausted. Use try-except or default parameter.\nBest Practice: Handle generator exhaustion with try-except or next() default parameter."}
{"text": "Prompt: Fix a Python error.\nError: MemoryError at line 3\nMessage: unable to allocate memory\nCode line: big_list = [0] * 10**10\nVariables: big_list\nIntent: memory allocation\nCompletion: Corrected Code:\n```python\ntry:\n    big_list = [0] * min(size, 10**6)  # reasonable limit\nexcept MemoryError:\n    big_list = []  # fallback\n```\nExplanation: MemoryError occurs with excessive memory allocation. Use reasonable limits and error handling.\nBest Practice: Implement memory-conscious data structures and proper error handling."}
{"text": "Prompt: Fix a Java error.\nError: StackOverflowError at line 4\nMessage: stack overflow\nCode line: return method1();\nVariables: None\nIntent: method call\nCompletion: Corrected Code:\n```java\nprivate int depth = 0;\npublic int method1() {\n    if (depth++ > 1000) return 0;  // prevent overflow\n    return method2();\n}\n```\nExplanation: StackOverflowError occurs with infinite recursion. Add depth limiting or iterative approach.\nBest Practice: Monitor recursion depth and use iterative solutions when possible."}
{"text": "Prompt: Fix a C++ error.\nError: runtime_error at line 5\nMessage: division by zero\nCode line: result = numerator / denominator;\nVariables: numerator, denominator, result\nIntent: arithmetic\nCompletion: Corrected Code:\n```cpp\nif (denominator != 0) {\n    result = numerator / denominator;\n} else {\n    throw std::invalid_argument('Division by zero');\n}\n```\nExplanation: Runtime error occurs with division by zero. Check denominator before division.\nBest Practice: Validate mathematical operations and provide meaningful error messages."}
{"text": "Prompt: Fix a JavaScript error.\nError: URIError at line 3\nMessage: URI malformed\nCode line: const decoded = decodeURIComponent(malformedURI);\nVariables: decoded, malformedURI\nIntent: URL decoding\nCompletion: Corrected Code:\n```javascript\ntry {\n    const decoded = decodeURIComponent(malformedURI);\n} catch (URIError) {\n    const decoded = malformedURI;  // fallback to original\n}\n```\nExplanation: URIError occurs with malformed URI strings. Use try-catch for URI operations.\nBest Practice: Always handle URI encoding/decoding errors with proper fallbacks."}
{"text": "Prompt: Fix a Python error.\nError: AssertionError at line 3\nMessage: assertion failed\nCode line: assert x > 0, 'x must be positive'\nVariables: x\nIntent: validation\nCompletion: Corrected Code:\n```python\nif x <= 0:\n    raise ValueError('x must be positive')\n# or: x = max(x, 1)  # ensure positive\n```\nExplanation: AssertionError occurs when assertion fails. Use explicit validation instead of assertions for user input.\nBest Practice: Use assertions for debugging, explicit checks for user input validation."}
{"text": "Prompt: Fix a Java error.\nError: InterruptedException at line 4\nMessage: thread interrupted\nCode line: Thread.sleep(1000);\nVariables: None\nIntent: threading\nCompletion: Corrected Code:\n```java\ntry {\n    Thread.sleep(1000);\n} catch (InterruptedException e) {\n    Thread.currentThread().interrupt();\n    return;  // or handle appropriately\n}\n```\nExplanation: InterruptedException occurs when thread is interrupted. Always handle interrupted exceptions properly.\nBest Practice: Restore interrupt status and handle interruption gracefully in threaded code."}
